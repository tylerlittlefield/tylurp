---
title: 'drake: build workflows with R'
author: ~
date: '2018-02-03'
slug: drake-build-workflows-with-r
categories: ['r']
tags: ['r']
---

![](https://cdn-images-1.medium.com/max/1600/1*0msxQhIX1Wj_LSuY5GwFzg.gif)

# Introduction

**`drake`** is a really cool R package designed to manage workflows. It's described as a computational engine for data science projects. The goal is to keep results up to date while also skipping anything that hasn't changed. As a result, users can scale their work, skip redundant work, and reap the benefits of reproducibility.

> [_"What gets done stays done."_](https://github.com/ropensci/drake)

To no suprise, the package is part of the [rOpenSci](https://ropensci.org) project, a community devoted to transparent research practices and reproducibility. It was covered during Jenny Bryan's workshop at [#rstudioconf](https://twitter.com/search?q=%23rstudioconf&src=typd) in San Diego. You can see the slides [here](https://krlmlr.github.io/drake-pitch/#1).^[https://krlmlr.github.io/drake-pitch/#1] As I write this, I'm not positive that there is a recording of this workshop. I reached out to Kirill MÃ¼ller and [he wasn't sure either](https://twitter.com/krlmlr/status/960056569466703872) but stay tuned for a text version of the material. Now let's dive into the code.

# Use `drake` to scrape tweets

The goal is to make a workflow for scraping tweets. Let's start by loading the libraries we need:

```{r, message = FALSE}
library(drake)   # workflow manager
library(rtweet)  # gather tweets
library(dplyr)   # data wrangling
library(ggplot2) # plotting
library(tibble)  # pretty dataframes
```

Next, let's make a list of the hashtags of interest:

```{r}
hashtag_list <- c("#rstats",
                  "#tidyverse",
                  "#dplyr",
                  "#data.table")
```

Now it's time to use `drake`. We start off by creating a `drake_plan`, we'll call this `data_plan`:

```{r}
data_plan <- drake_plan(
  recent = search_tweets2(hashtag_list, n = 10000, type = "recent"),
  strings_in_dots = "literals"
)
```

Then we create a `drake_plan` for our desired outputs, we'll call this `output_types`:

```{r}
output_types <- drake_plan(
  top_tweeters = make_my_table(dataset__),
  plot = make_my_plot(dataset__)
)
```

We need to create functions for our `output_types` object. One function for creating a table of the top tweeters (users who use a hashtag the most) and another function for plotting the number of tweets per hashtag:

```{r}
make_my_table <- function(tweets){
    data.frame(tweets %>% 
                 select(screen_name, query) %>% 
                 group_by_all() %>% 
                 count() %>% 
                 ungroup() %>% 
                 arrange(desc(n)))
}

make_my_plot <- function(tweets){
  ggplot(tweets) +
    geom_histogram(aes(created_at, fill = query)) +
    scale_y_log10()
}
```

We use `plan_analyses` to bridge our data with the desired outputs:

```{r}
output_plan <- plan_analyses(
  plan = output_types,
  datasets = data_plan
)
```

Finally, we bring everything together using `rbind` and `make`, the central most important function in `drake`:

```{r, message=FALSE, warning=FALSE}
whole_plan <- rbind(data_plan, output_plan)
make(whole_plan)

# cache /Users/tylerlittlefield/Github/tylurp/.drake
# connect 7 imports: data_plan, make_my_table, make_my_plot, hashtag_list, whol...
# connect 3 targets: recent, top_tweeters_recent, plot_recent
# check 16 items: aes, arrange, count, created_at, data.frame, desc, geom_histo...
# check 2 items: make_my_plot, make_my_table
# check 1 item: recent
# target recent
# Searching for tweets...
# Finished collecting tweets!
# Searching for tweets...
# Finished collecting tweets!
# Searching for tweets...
# Finished collecting tweets!
# Searching for tweets...
# Finished collecting tweets!
# check 2 items: plot_recent, top_tweeters_recent
# target plot_recent
# target top_tweeters_recent
```

Once our workflow has been made, we can play around with the targets we created:

```{r, message=FALSE, warning=FALSE}
readd(plot_recent)
readd(top_tweeters_recent) %>% as_tibble()
```

To visualize our workflow we can use `vis_drake_graph`:

```{r, message=FALSE}
config <- drake_config(whole_plan)
vis_drake_graph(config)
```

If we change a parameter in the workflow, we can see this in the workflow diagram:

```{r, message=FALSE}
hashtag_list <- c("#tidyverse",
                  "#dplyr",
                  "#data.table")

config <- drake_config(whole_plan)
vis_drake_graph(config)
```

# Summary

This package seems like it could be really useful. The idea of binding components of a workflow is really interesting. Just thinking of a workflow as a dataframe where each row is a step towards an output is also a really cool idea and I'm excited to explore `drake` further.
