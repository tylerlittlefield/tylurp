---
title: Measuring performance
author: ~
date: '2018-02-13'
slug: measuring-performance
categories: ['r']
tags: []
---



<p>With any data science project there may be times where performance is a concern. This might be a result of a lack of resources or the size of the data involved. In any case, we can use <code>microbenchmark</code> an R package designed to make benchmarking easy.</p>
<p>I discovered this package on Stack Overflow as someone measured the performance of their answer among others. Hadley Wickham also writes about <code>microbenchmark</code> in his <a href="https://adv-r.hadley.nz/performance.html">Advanced R</a> book. As of late, what I have found really informative is an <a href="https://stackoverflow.com/a/48708439/7362046">answer on Stack Overflow by Jaap</a> where he measures the performance of many alternative solutions for a specific problem in this case, finding the sequence of numbers in a vector.</p>
<p>For this post, let’s consider the long to wide problem. We want to take a long dataset and make it wide. Furthermore, we want to insure that the solution to this problem is faster than the alternatives we can come up with. Off the top of my head, I can think of 5 ways to do this:</p>
<ol style="list-style-type: decimal">
<li><code>spread</code> from the <code>tidyr</code> package</li>
<li><code>dcast</code> from the <code>reshape2</code> package (superseeded by <code>tidyr</code>)</li>
<li><code>reshape</code> from the <code>stats</code> package</li>
<li><code>aggregate</code> from the <code>stats</code> package</li>
<li><code>dcast</code> from <code>data.table</code></li>
</ol>
<p>Once we come up with the possible solutions to this problem, we can then create a reproducible dataset that can be increased easily:</p>
<pre class="r"><code>library(dplyr)</code></pre>
<pre><code>## 
## Attaching package: &#39;dplyr&#39;</code></pre>
<pre><code>## The following objects are masked from &#39;package:stats&#39;:
## 
##     filter, lag</code></pre>
<pre><code>## The following objects are masked from &#39;package:base&#39;:
## 
##     intersect, setdiff, setequal, union</code></pre>
<pre class="r"><code>library(tidyr)

# Adjust n_xyz to increase size of dataset
n_obs = 1e2
n_date = n_obs - 1

# Create dataset
stocks &lt;- data.frame(
  time = as.Date(&#39;2009-01-01&#39;) + 0:n_date,
  X = rnorm(n_obs, 0, 1),
  Y = rnorm(n_obs, 0, 2),
  Z = rnorm(n_obs, 0, 4)
)

# Gather wide to long
stocksm &lt;- stocks %&gt;% gather(stock, price, -time)

# Create data.table object for benchmarking purposes
stocksm_dt &lt;- data.table::as.data.table(stocksm)</code></pre>
<p>The result looks like:</p>
<pre class="r"><code>as_tibble(stocksm)</code></pre>
<pre><code>## # A tibble: 300 x 3
##    time       stock  price
##    &lt;date&gt;     &lt;chr&gt;  &lt;dbl&gt;
##  1 2009-01-01 X      2.66 
##  2 2009-01-02 X     -1.42 
##  3 2009-01-03 X      1.46 
##  4 2009-01-04 X      1.03 
##  5 2009-01-05 X     -0.409
##  6 2009-01-06 X      1.27 
##  7 2009-01-07 X     -1.46 
##  8 2009-01-08 X     -0.261
##  9 2009-01-09 X      1.19 
## 10 2009-01-10 X      0.586
## # ... with 290 more rows</code></pre>
<p>We will measure the performance of the following functions:</p>
<pre class="r"><code>tidyr::spread(stocksm, stock, price)
reshape2::dcast(stocksm, time ~ stock)
stats::aggregate(price ~ time, stocksm, I)
stats::reshape(stocksm_dt, idvar = &quot;time&quot;, timevar = &quot;stock&quot;, direction = &quot;wide&quot;)
data.table::dcast(stocksm_dt, time ~ stock)
data.table::dcast(stocksm_dt, time ~ stock, value.var = &quot;time&quot;) # enhanced</code></pre>
<p>All of these (more or less) return:</p>
<pre class="r"><code>stocksm %&gt;% 
  spread(stock, price) %&gt;% 
  head()</code></pre>
<pre><code>##         time          X          Y          Z
## 1 2009-01-01  2.6561114  2.9237877  4.7201400
## 2 2009-01-02 -1.4170240  0.6800151  4.0700212
## 3 2009-01-03  1.4622730 -0.4415728 -2.0001695
## 4 2009-01-04  1.0277796 -0.1996935  5.0680620
## 5 2009-01-05 -0.4093304  1.1553886 -0.1984743
## 6 2009-01-06  1.2702285 -4.7606719  4.6680168</code></pre>
<p>And the <em>more or less</em> part is important and herein lies one of the things I learned from Jaaps answer on Stack Overflow. When measuring performance we can check to see if the output is equal among all possible solutions. We can do this with the <code>all.equal</code> function, i.e. <code>all.equal(x, y)</code> where <code>x</code> is our target object and <code>y</code> is our current object to be used for testing ‘near equality’ between the two:</p>
<pre class="r"><code>all.equal(
  tidyr::spread(stocksm, stock, price),
  reshape2::dcast(stocksm, time ~ stock)
)</code></pre>
<pre><code>## [1] TRUE</code></pre>
<p>We can see that <code>reshape2</code> and <code>tidyr</code> return the same output. This isn’t suprising as <code>tidyr</code> superseeded <code>reshape2</code> and is authored by the same person. However, if we test the outputs of the other solutions we’ll see that the output is not the same:</p>
<pre class="r"><code>isTRUE(all.equal(
  tidyr::spread(stocksm, stock, price),
  stats::aggregate(price ~ time, stocksm, I)
))</code></pre>
<pre><code>## [1] FALSE</code></pre>
<p>The differences between the four solutions has to do with the structure of the output. Remove the <code>isTRUE</code> surrounding the <code>all.equal</code> call in order to see these differences. If we treat each operation as a matrix the only difference between each of the outputs is the <code>dimnames</code> or the names of the dimensions/variables in each R object.</p>
<pre class="r"><code>all.equal(
  tidyr::spread(stocksm, stock, price) %&gt;% as.matrix(),
  stats::aggregate(price ~ time, stocksm, I) %&gt;% as.matrix()
)</code></pre>
<pre><code>## [1] &quot;Attributes: &lt; Component \&quot;dimnames\&quot;: Component 2: 3 string mismatches &gt;&quot;
## [2] &quot;300 string mismatches&quot;</code></pre>
<p>Since we are only concerned with converting a long dataset to wide, let’s not worry about the underlying structure and proceed to measure the performance of all methods.</p>
<p>We can create the functions for running the benchmarks and keeping the <code>microbenchmark</code> call a little cleaner:</p>
<pre class="r"><code>tidyr_spread &lt;- function(dat) {
  tidyr::spread(dat, stock, price)
}

reshape_decast &lt;- function(dat) {
  reshape2::dcast(dat, time ~ stock)
}

stats_aggregate &lt;- function(dat) {
  stats::aggregate(price ~ time, dat, I)
}

stats_reshape &lt;- function(dat) {
  stats::reshape(dat, idvar = &quot;time&quot;, timevar = &quot;stock&quot;, direction = &quot;wide&quot;)
}

data.table_dcast &lt;- function(dat) {
  data.table::dcast(dat, time ~ stock)
}

data.table_dcast_enhanced &lt;- function(dat) {
  data.table::dcast(dat, time ~ stock, value.var = &quot;time&quot;)
}</code></pre>
<p>Finally, we can benchmark!</p>
<pre class="r"><code>bms &lt;- microbenchmark::microbenchmark(
  tidyr_spread = tidyr_spread(stocksm),
  reshape_decast = reshape_decast(stocksm),
  stats_aggregate = stats_aggregate(stocksm),
  stats_reshape = stats_reshape(stocksm),
  data.table_dcast = data.table_dcast(stocksm_dt),
  data.table_dcast_enhanced = data.table_dcast_enhanced(stocksm_dt),
  times = 100
)</code></pre>
<p>The results:</p>
<div class="figure">
<img src="https://raw.githubusercontent.com/tyluRp/tylurp/master/figure/longtowidebenchmark.png" />

</div>
